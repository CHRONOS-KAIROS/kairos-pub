// a schema is a dict with an id, name, and steps
"@namespace": { // called "context" before...
    "jonmay": "https://jonmay.net/kairos.namespace.json",
    // not part of mvp
    //   "sbu": "http://www.stonybrook.edu/kairos.json",
    //    "kairos": "https://darpa.mil/i2o/kairos.official.namespace.json",
    
    //   so that a file can be included instead of needing a globally accessible url
    //    "localex": "file/relative/path/to/file.json",
}

// several schemas may be defined here
"@schemas": [
    // wait...this is illegal...
    {
    // id is a namespaced string
    "@id": "jonmay:myschema_1",
        "@super": ["jonmay:297u3883",], // could also call "parent"
    // name is a human readable string
    "name": "a minimal viable schema that is a valid, if vacuous, schema",
    // steps is a dict cont
    "steps": {
        "events": [
            // an event is a dict with many possible fields but only these *must exist*
            {
                "@type": "jonmay:nonsense", // <--this is the same as a schema's "id" if you're using a complex event. if parent with same varname is a mismatched type, a validator should complain
                "@varname": "myevent_1",  // <--this is for relative ordering, 
                "@ref": ["jonnmay:297u3883.myevent_1",], // direct call to event in super. mandatory if actually overriding. otherwise presumed novel. one reference per parent. at most 1:1 mapping. semantics of multiple inheritance is currently not defined, this simply expresses how to represent it.
            }
            {
                "@type": "jonmay:nonsense",
                "@varname": "myevent_2",  
            }

        ]
        "order": [
            {
                "@precedes": ["myevent_1", "myevent_2"] // order inherits from super; if precedes order conflicts this is a validation error. cycle is a validation error. overlaps should not throw any errors because there is no expression of "does not overlap".

                //  a -> b
                //  c -> b
                // need we specify a and c at same time vs there being some ordering?
                // esp. if
                // d -> a
                // d -> c
                //    a
                // d      b
                //    c

                "@precedes": ["1", "2"]
                "@precedes": ["1", "3"]
                "@precedes": ["1", "4"]
                "@precedes": ["1", "5"]

                "@precedes": ["1", ["2","3","4","5"]]


                "@precedes": [["1","2","3"],["4","5","6"]]
                
                ["1", ["2", "3","4","5"]]
                
                // Partial ordering defined here...but it's not MVP!
                // what is the form of a partial ordering specification?
            }
        ]
    }
    }
    ]

// what is the form of a namespace json?



events: url/to/hierarchy

// or

events:


1 -> 13 -> 297u3883


a -> b
a -> c

b -> d
c -> d

d = a:b:d or a:c:d?
