package com.ncc.kairos.moirai.zeus.api;

import com.ncc.kairos.moirai.zeus.model.*;
import com.ncc.kairos.moirai.zeus.resources.Constants;
import com.ncc.kairos.moirai.zeus.services.DockerService;
import com.ncc.kairos.moirai.zeus.services.KairosUserService;
import com.ncc.kairos.moirai.zeus.services.TAServices;
import com.ncc.kairos.moirai.zeus.services.UserServicesService;
import io.swagger.annotations.ApiParam;
import org.modelmapper.ModelMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.context.request.NativeWebRequest;
import org.springframework.web.server.ResponseStatusException;

import javax.validation.Valid;
import javax.validation.constraints.NotNull;
import java.util.*;

/**
 * Controller Implementation of the AuthenticateApi that is autogenerated by
 * swagger-codegen. Handles receiving a username and password, authenticating it
 * against the database, and returning a jwt.
 *
 * @author ryan scott
 * @version 0.1
 */
@Controller
@RequestMapping("${openapi.moiraiZeus.base-path:}")
public class ServicesApiController implements ServicesApi {

    private final NativeWebRequest request;

    @Autowired
    public ServicesApiController(NativeWebRequest request) {
        this.request = request;
    }

    @Autowired
    private UserServicesService userServicesService;

    @Autowired
    private KairosUserService kairosUserService;

    @Autowired
    private TAServices taServices;

    @Autowired
    private DockerService dockerService;

    @Autowired
    private ModelMapper looseModelMapper;

    @Override
    public Optional<NativeWebRequest> getRequest() {
        return Optional.ofNullable(this.request);
    }

    @Override
    public ResponseEntity<List<Service>> listServices(
            @ApiParam(value = "name value for service") @Valid @RequestParam(value = "name", required = false) String name) {
        List<Service> parsedList = userServicesService.getFilteredServiceList(name, (JwtUser) this.request.getAttribute(Constants.ATTRIBUTE_JWTUSER, 0));
        HttpStatus status = parsedList.size() > 0 ? HttpStatus.OK : HttpStatus.NO_CONTENT;
        return new ResponseEntity<>(parsedList, status);
    }

    /**
     * Handles taking a cypher query from the request body and passing to a Neo4J
     * repository.
     *
     * @param body The request body as json with a 'queryString' containing the
     *             cypher query.
     * @return String The response of the query.
     */
    @Override
    @PreAuthorize("hasAnyAuthority('ADMIN', 'CLOTHO-PROVISION')")
    public ResponseEntity<StringResponse> provisionClotho(
            @ApiParam("Launches Ansible with the selected parameters") @Valid @RequestBody ClothoServiceDto body) {
        JwtUser jwtUser = (JwtUser) this.request.getAttribute(Constants.ATTRIBUTE_JWTUSER, 0);
        jwtUser = this.kairosUserService.findUserByUsername(jwtUser.getUsername());
        
        Service service = setNewServiceDefaults(looseModelMapper.map(body, Service.class), jwtUser);
        service.setSubtype(body.getDatabaseType().toString());

        String response = String.format("Account Name: %1$s  Database Type: %2$s   Database Name: %3$s ",
                jwtUser.getUsername(), service.getSubtype(), service.getName());

        try {
            taServices.provisionClotho(service, jwtUser);
            response += "Successfully Provisioned Clotho";
            return new ResponseEntity<>(new StringResponse().value(response), HttpStatus.OK);
        }
        catch (ResponseStatusException e){
            throw e;
        }
        catch(Exception e) {
            Service returnService = this.userServicesService.saveNewService(service, jwtUser);
            returnService.status(Constants.SERVICE_STATUS_FAILED);
            this.userServicesService.updateServiceStatus(returnService);
            response += "Unable to Provision Clotho";
            return new ResponseEntity<>(new StringResponse().value(response), HttpStatus.BAD_REQUEST);
        }
    }

    private Service setNewServiceDefaults(Service service, JwtUser jwtUser) {
        service.setAccess(Constants.PRIVATE_ACCESS_KEYWORD);
        service.setType(Constants.CLOTHO_TYPE);
        service.setStatus(Constants.IN_PROGRESS_STATUS);
        service.setTeamName(jwtUser.getTeamName());
        return service;
    }

    /**
     * Terminates Active services hosted on AWS and updates their internal status to 'Terminated'.
     * @param service service to be turned off and updated
     * @return String The response of the delete.
     */
    @Override
    @PreAuthorize("hasAnyAuthority('ADMIN', 'CLOTHO-TERMINATE')")
    public ResponseEntity<StringResponse> terminateClothoInstance(
            @ApiParam(value = "Terminates clotho with the selected parameters") @Valid @RequestBody Service service) {
        JwtUser jwtUser = (JwtUser) this.request.getAttribute(Constants.ATTRIBUTE_JWTUSER, 0);

        String response = String.format("Account Name: %1$s  Instance Id: %2$s ",
                jwtUser.getUsername(), service.getAwsInstances());

        try {
            taServices.terminateClothoInstance(service, jwtUser);
            response += " Successfully Terminated Clotho intance";
            return new ResponseEntity<>(new StringResponse().value(response), HttpStatus.OK);
        }
        catch (ResponseStatusException e){
            throw e;
        }
        catch(Exception e) {
            service.status(Constants.SERVICE_STATUS_FAILED);
            this.userServicesService.updateServiceStatus(service);
            response += " Unable to terminate Clotho";
            return new ResponseEntity<>(new StringResponse().value(response), HttpStatus.BAD_REQUEST);
        }
    }

    @Override
    public ResponseEntity<StringResponse> terminateServiceInstance(
            @ApiParam(value = "Terminates service with the selected parameters"  )
            @Valid @RequestBody Service service) {
        switch(service.getType().toLowerCase()) {
            case "clotho":
                return terminateClothoInstance(service);
            default:
                throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Unable to delete service type " + service.getType() + ".");
        }
    }

    @Override
    public ResponseEntity<StringResponse> updateServiceInstance (
            @ApiParam(value = "Updates service with the selected parameters")
            @Valid @RequestBody Service service) {
        try {
            this.userServicesService.updateServiceDetails(service);
            return new ResponseEntity<>(new StringResponse().value("Updated service"), HttpStatus.OK);
        } catch (Exception e) {
            return new ResponseEntity<>(new StringResponse().value("Failed to update service"), HttpStatus.BAD_REQUEST);
        }
    }

    @Override
    @PreAuthorize("hasAnyAuthority('ADMIN', 'DOCKER-CREATE-REGISTRY')")
    public ResponseEntity<StringResponse> createDockerRegistry(
            @ApiParam(value = "Connects to a Flask service that creates a private Docker registry.")
            @Valid @RequestBody StringRequest stringRequest) {
        JwtUser jwtUser = (JwtUser) this.request.getAttribute(Constants.ATTRIBUTE_JWTUSER, 0);
        try {
            dockerService.createDockerRegistry(stringRequest.getValue(), jwtUser.getTeamName());
            return new ResponseEntity<>(new StringResponse().value("Created Docker Registry"), HttpStatus.OK);
        }
        catch (ResponseStatusException e) {
            throw e;
        }
        catch(Exception e) {
            return new ResponseEntity<>(new StringResponse().value("Unable to create Docker registry"), HttpStatus.BAD_REQUEST);
        }
    }

    @Override
    @PreAuthorize("hasAnyAuthority('ADMIN', 'DOCKER-RESET-REGISTRY-PASSWORD')")
    public ResponseEntity<StringResponse> resetDockerRegistryPassword(
            @ApiParam(value = "Password to reset password to"  ) 
            @Valid @RequestBody StringRequest stringRequest) {
        JwtUser jwtUser = (JwtUser) this.request.getAttribute(Constants.ATTRIBUTE_JWTUSER, 0);
        try {
            dockerService.resetDockerPassword(stringRequest.getValue(), jwtUser.getTeamName());
            return new ResponseEntity<>(new StringResponse().value("Reset Docker registry password"), HttpStatus.OK);
        }
        catch (ResponseStatusException e) {
            throw e;
        }
        catch(Exception e) { 
            return new ResponseEntity<>(new StringResponse().value("Unable to reset Docker registry password"), HttpStatus.BAD_REQUEST);
        }
    }

    @Override
    public ResponseEntity<StringResponse> refreshDockerRegistry() {
        JwtUser jwtUser = (JwtUser) this.request.getAttribute(Constants.ATTRIBUTE_JWTUSER, 0);
        jwtUser = kairosUserService.findUserByUsername(jwtUser.getUsername());
        try {
            dockerService.refreshRegistry(jwtUser.getTeamName());
            return new ResponseEntity<>(new StringResponse().value("Success"), HttpStatus.OK);
        }
        catch (ResponseStatusException e) {
            throw e;
        }
        catch(Exception e) {
            return new ResponseEntity<>(new StringResponse().value("Unable to refresh Docker registry information"), HttpStatus.BAD_REQUEST);
        }
    }

    @Override
    public ResponseEntity<StringResponse> restoreDockerRegistry() {
        try {
            dockerService.restoreAllRegistries();
            dockerService.refreshAllRegistries();
            return new ResponseEntity<>(new StringResponse().value("Success"), HttpStatus.OK);
        }
        catch (ResponseStatusException e) {
            throw e;
        }
        catch(Exception e) {
            return new ResponseEntity<>(new StringResponse().value("Unable to restore Docker registry information"), HttpStatus.BAD_REQUEST);
        }
    }

    @Override
    public ResponseEntity<DockerRegistry> getDockerRegistry() {
        JwtUser jwtUser = (JwtUser) this.request.getAttribute(Constants.ATTRIBUTE_JWTUSER, 0);
        jwtUser = kairosUserService.findUserByUsername(jwtUser.getUsername());

        try {
            List<DockerRegistry> returnedList = dockerService.getDockerRegistries(jwtUser.getTeamName());
            if (returnedList.size() == 1) {
                return new ResponseEntity<>(returnedList.get(0), HttpStatus.OK);
            } else {
                throw new ResponseStatusException(HttpStatus.EXPECTATION_FAILED, "Expected 1 associated registry found "+returnedList.size()+".");
            }
        }
        catch (ResponseStatusException e) {
            throw e;
        }
        catch (Exception e) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Unable to retrieve Docker registry information");
        }
    }

    @Override
    @PreAuthorize("hasAuthority('ADMIN')")
    public ResponseEntity<List<DockerRegistry>> getDockerRegistryForUser(
            @ApiParam(value = "UserName") 
            @Valid @RequestParam(value = "username.", required = false) String teamname) {
        try {
            List<DockerRegistry> returnedList = dockerService.getDockerRegistries(teamname);
            return new ResponseEntity<>(returnedList, HttpStatus.OK);
        }
        catch (ResponseStatusException e) {
            throw e;
        }
        catch(Exception e) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Unable to retrieve Docker registry information");
        }
    }

    @Override
    @PreAuthorize("hasAnyAuthority('ADMIN', 'DOCKER-UPLOAD-DELETE')")
    public ResponseEntity<StringResponse> destroyDockerUploads(
        @NotNull @ApiParam(value = "DockerUpload id of DockerUpload to delete", required = true) 
        @Valid @RequestParam(value = "id", required = true) String id) {
        JwtUser jwtUser = (JwtUser) this.request.getAttribute(Constants.ATTRIBUTE_JWTUSER, 0);
        // try {
        //     // Temporarily disabled while I verify that there isnt a bug or until I fix it
        //     this.dockerService.deleteDockerUpload(id, jwtUser);
        //     return new ResponseEntity<>(new StringResponse().value("Success: Deleted Docker Upload"), HttpStatus.OK);
        // }
        // catch (ResponseStatusException e) {
        //     throw e;
        // }
        // catch(Exception e) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Unable to Delete Docker upload");
        // }
    }
}
