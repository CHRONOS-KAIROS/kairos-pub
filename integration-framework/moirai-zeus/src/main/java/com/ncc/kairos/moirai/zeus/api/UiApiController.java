package com.ncc.kairos.moirai.zeus.api;

import com.ncc.kairos.moirai.zeus.dao.FeatureFlagOverrideRepository;
import com.ncc.kairos.moirai.zeus.dao.FeatureFlagRepository;
import com.ncc.kairos.moirai.zeus.model.FeatureFlag;
import com.ncc.kairos.moirai.zeus.model.FeatureFlagOverride;
import com.ncc.kairos.moirai.zeus.model.JwtUser;
import com.ncc.kairos.moirai.zeus.model.StringResponse;
import com.ncc.kairos.moirai.zeus.resources.Constants;
import com.ncc.kairos.moirai.zeus.services.KairosUserService;
import io.swagger.annotations.ApiParam;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.context.request.NativeWebRequest;

import javax.validation.Valid;

import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

/**
 * Controller Implementation of the UiApi that is autogenerated by
 * swagger-codegen.
 *
 * @author Ryan Scott
 */
@Controller
@RequestMapping("${openapi.moiraiZeus.base-path:}")
public class UiApiController implements UiApi {

    private final NativeWebRequest request;

    @Autowired
    public UiApiController(NativeWebRequest request) {
        this.request = request;
    }

    public Optional<NativeWebRequest> getRequest() {
        return Optional.ofNullable(this.request);
    }

    @Autowired
    private FeatureFlagRepository featureFlagRepository;

    @Autowired
    private FeatureFlagOverrideRepository featureFlagOverrideRepository;

    @Autowired
    private KairosUserService kairosUserService;

    @Override
    @PreAuthorize("hasAuthority('ADMIN')")
    public ResponseEntity<List<FeatureFlag>> getFeatureFlags() {
        List<FeatureFlag> flags = featureFlagRepository.findAll();
        return new ResponseEntity<>(flags, HttpStatus.OK);
    }

    @Override
    public ResponseEntity<List<FeatureFlag>> getActiveFeatureFlags() {
        JwtUser jwtUser = (JwtUser) this.request.getAttribute(Constants.ATTRIBUTE_JWTUSER, 0);
        jwtUser = this.kairosUserService.findUserByUsername(jwtUser.getUsername());

        List<FeatureFlag> storedFlags = featureFlagRepository.findAll();
        List<FeatureFlag> activeFlags = new ArrayList<>();
        for (FeatureFlag flag : storedFlags) {
            if (jwtUser != null  && jwtUser.getTeamName() != null && jwtUser.getTeamName().equalsIgnoreCase("nist") 
                && (flag.getName().contains("upload") || flag.getName().contains("download"))) {
                flag.setEnabled(true);
            } else if (flag.getOverrides() != null) { 
                List<FeatureFlagOverride> activeRules = new ArrayList<>();
                activeRules.addAll(flag.getOverrides().stream().filter(override -> this.checkOverride(override))
                        .collect(Collectors.toList()));
                // Assuming there are no conflicting overrides just grab the first valid one to return
                if (!activeRules.isEmpty()) {
                    flag.setEnabled(activeRules.get(0).getOverride());
                }
            }
            activeFlags.add(flag);
        }
        return new ResponseEntity<>(activeFlags, HttpStatus.OK);
    }

    // the eventual teamname / user / authority specific overrides will be checked here
    private boolean checkOverride(FeatureFlagOverride override) {
        OffsetDateTime now = OffsetDateTime.now();
        return now.isAfter(override.getStartDate()) && now.isBefore(override.getEndDate());
    }

    @Override
    @PreAuthorize("hasAuthority('ADMIN')")
    public ResponseEntity<StringResponse> newFeatureFlag(@ApiParam(value = "new feature flag") @Valid @RequestBody FeatureFlag featureFlag) {
        FeatureFlag nameCheck = featureFlagRepository.findByName(featureFlag.getName());
        List<FeatureFlagOverride> savedOverrides = new ArrayList<>();
        if (nameCheck != null) {
            return new ResponseEntity<>(HttpStatus.CONFLICT);    
        }
        if (!featureFlag.getOverrides().isEmpty()) {
            for (FeatureFlagOverride override : featureFlag.getOverrides()) {
                // If it is a new Feature flag then these are all new overrides with it.
                savedOverrides.add(featureFlagOverrideRepository.save(override));
            }
        }
        featureFlag.setId(null);
        featureFlag.overrides(savedOverrides);
        featureFlagRepository.save(featureFlag);
        return new ResponseEntity<>(HttpStatus.OK);
    }

    @Override
    @PreAuthorize("hasAuthority('ADMIN')")
    public ResponseEntity<StringResponse> updateFeatureFlag(@ApiParam(value = "file id", required = true) @PathVariable("id") String id, @ApiParam(value = "Update the featureFlag given the id") @Valid @RequestBody FeatureFlag featureFlag) {
        List<FeatureFlagOverride> savedOverrides = new ArrayList<>();
        featureFlag.getOverrides().stream().forEach(override -> savedOverrides.add(featureFlagOverrideRepository.save(override)));
        Optional<FeatureFlag> updateMe = featureFlagRepository.findById(id);
        if (updateMe.isPresent()) {
            updateMe.get().enabled(featureFlag.getEnabled())
                .overrides(savedOverrides);
            featureFlagRepository.save(updateMe.get());
        }
        return new ResponseEntity<>(HttpStatus.OK);
    }

    @Override
    @PreAuthorize("hasAuthority('ADMIN')")
    public ResponseEntity<StringResponse> deleteFeatureFlag(@ApiParam(value = "feature flag to delete"  )  @Valid @RequestBody FeatureFlag featureFlag) {
        List<FeatureFlagOverride> associatedOverrides = new ArrayList<>();
        if (!featureFlagRepository.existsById(featureFlag.getId())) {
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        }
        Optional<FeatureFlag> storedFeature = featureFlagRepository.findById(featureFlag.getId());
        // Delete children(Overrides) first
        if (storedFeature.isPresent() && !storedFeature.get().getOverrides().isEmpty()) {
            associatedOverrides.addAll(storedFeature.get().getOverrides());
            featureFlagRepository.save(storedFeature.get().overrides(null)); // remove foreign keys
            associatedOverrides.stream().forEach(override -> featureFlagOverrideRepository.delete(override));
        }
        // Delete parent(featureFlag)
        featureFlagRepository.delete(storedFeature.get());
        return new ResponseEntity<>(HttpStatus.OK);
    }
    
}
