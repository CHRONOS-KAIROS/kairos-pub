package com.ncc.kairos.moirai.zeus.api;

import com.ncc.kairos.moirai.zeus.dao.JwtPermissionRepository;
import com.ncc.kairos.moirai.zeus.dao.JwtRoleRepository;
import com.ncc.kairos.moirai.zeus.dao.ZeusSettingRepository;
import com.ncc.kairos.moirai.zeus.model.*;
import com.ncc.kairos.moirai.zeus.resources.Constants;
import com.ncc.kairos.moirai.zeus.security.payloads.JwtUserDetails;
import com.ncc.kairos.moirai.zeus.security.utils.JwtUtils;
import com.ncc.kairos.moirai.zeus.services.ContactRequestService;
import com.ncc.kairos.moirai.zeus.services.KairosEmailService;
import com.ncc.kairos.moirai.zeus.services.KairosUserService;
import io.swagger.annotations.ApiParam;
import org.modelmapper.ModelMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.context.request.NativeWebRequest;
import org.springframework.web.server.ResponseStatusException;

import javax.validation.Valid;

import java.time.LocalDateTime;
import java.util.Calendar;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

import static com.ncc.kairos.moirai.zeus.utililty.PasswordUtil.passwordValidation;

/**
 * Controller Implementation of the AuthenticateApi that is autogenerated by
 * swagger-codegen. Handles receiving a username and password, authenticating it
 * against the database, and returning a jwt.
 *
 * @author ryan scott
 * @version 0.1
 */
@RestController
@RequestMapping("${openapi.moiraiZeus.base-path:}")
public class UsersApiController implements UsersApi {

    private final NativeWebRequest request;

    @Autowired
    public UsersApiController(NativeWebRequest request) {
        this.request = request;
    }

    @Override
    public Optional<NativeWebRequest> getRequest() {
        return Optional.ofNullable(this.request);
    }

    @Autowired
    private JwtUtils jwtUtils;
    
    @Autowired
	AuthenticationManager authenticationManager;

    @Autowired
    private KairosEmailService kairosEmailService;

    @Autowired
    private KairosUserService kairosUserService;

    @Autowired
    private ContactRequestService contactRequestService;

    @Autowired
    private JwtPermissionRepository jwtPermissionRepo;

    @Autowired
    private JwtRoleRepository jwtRoleRepo;

    @Autowired
    private ZeusSettingRepository zeusSettingRepo;

    @Value("${jwt.password.expire.days}")
    private int passwordExpiration;

    private ModelMapper modelMapper = new ModelMapper();

    /**
     * Handles taking a new account request object and creation the jwtUser.
     *
     * @param registrationDto The request body as json with all required parameters
     *                       of a new jwtUser.
     * @returns success or failure.
     */
    @Override
    public ResponseEntity<StringResponse> register(
            @ApiParam("New user information") @Valid @RequestBody RegistrationDto registrationDto) {
        ZeusSetting registrationAllowed = zeusSettingRepo.findByName(Constants.ZS_REGISTRATION_ALLOWED);
        if (registrationAllowed != null && registrationAllowed.getValue().toUpperCase().equals("TRUE")) {
            JwtUser jwtUser = modelMapper.map(registrationDto, JwtUser.class);
            JwtRole subTeamRole = this.jwtRoleRepo.findByName(Constants.CREATE_SUB_TEAM_ROLE_NAME);
            if (subTeamRole == null) {
                subTeamRole = new JwtRole().name(Constants.CREATE_SUB_TEAM_ROLE_NAME).description("Allows User to create a login associated to the team")
                        .addPermissionsItem(this.jwtPermissionRepo.findByName(Constants.CREATE_SUB_TEAM_PERMISSION_NAME));
                subTeamRole = jwtRoleRepo.save(subTeamRole);
            }
            kairosUserService.assertUniqueUserName(jwtUser.getUsername());
            kairosUserService.assertUniqueEmailAddress(jwtUser.getEmailAddress());
            kairosUserService.assertUniqueTeamName(jwtUser.getTeamName());
            jwtUser.active(true);
            jwtUser.setPasswordExpiration(LocalDateTime.ofInstant(getPasswordExpiration().toInstant(), getPasswordExpiration().getTimeZone().toZoneId()).toLocalDate());
            jwtUser.addRolesItem(subTeamRole);
            kairosUserService.saveUserEncryptPassword(jwtUser);
            return new ResponseEntity<>(new StringResponse().value("New account " + registrationDto.getUsername() + " created."), HttpStatus.CREATED);
        } else {
            return new ResponseEntity<>(new StringResponse().value("New account registration is disabled at this time"), HttpStatus.FORBIDDEN);
        }
    }

    @Override
    public ResponseEntity<StringResponse> updateUserSettings(
            @ApiParam("updated user information") @Valid @RequestBody SettingsDto settingsDto) {
        JwtUser jwtUser = (JwtUser) this.request.getAttribute(Constants.ATTRIBUTE_JWTUSER, 0);
        getAuthentication(jwtUser.getUsername(), settingsDto.getCurrentPassword());

        //Jwt from cookie is an incomplete object.
        jwtUser = kairosUserService.findUserByUsername(jwtUser.getUsername());
        JwtUser newJwtSettings = modelMapper.map(settingsDto, JwtUser.class);

        kairosUserService.updateUser(jwtUser, newJwtSettings);

        return new ResponseEntity<>(new StringResponse().value("Account updated"), HttpStatus.OK);
    }

    /**
     * Returns the account information that matches the jwt that is passed in.
     * The security filter already handles validating the jwt and checking that an account is associated so we only have to return the account.
     * @return The account associated with the jwt.
     */
    @Override
    public ResponseEntity<JwtUser> getUserAccount() {
        JwtUser jwtUser = (JwtUser) this.request.getAttribute(Constants.ATTRIBUTE_JWTUSER, 0);
        JwtUser associatedAccount = this.kairosUserService.findUserByUsername(jwtUser.getUsername());

        //Make sure we don't pass anything for the password
        associatedAccount.setPassword("");
        return new ResponseEntity<>(associatedAccount, HttpStatus.OK);

    }


    /**
     * Handles taking a username and password as strings, validating against the
     * database, and returning a jwt.
     *
     * @param loginRequest The request body as json with a 'username' and
     *                     'password'.
     * @return Success or failure.
     */
    @Override
    public ResponseEntity<StringResponse> authenticate(
            @ApiParam("Authenticate user with password") @Valid @RequestBody ZeusLoginRequest loginRequest) {
        Authentication authentication = getAuthentication(loginRequest.getUsername(), loginRequest.getPassword());

        String jwt = jwtUtils.generateJwtToken(authentication);
        return new ResponseEntity<>(new StringResponse().value(jwt), HttpStatus.OK);
    }

    /**
     * Handles taking a email, finding the associated account, and emailing the
     * username.
     *
     * @param stringRequest The request body as json with a 'value' containing the
     *                      email.
     * @return Success or No content.
     */
    @Override
    public ResponseEntity<StringResponse> forgotUsername(
            @ApiParam("The email address of the user.") @Valid @RequestBody StringRequest stringRequest) {
        StringResponse stringResponse = new StringResponse();
        HttpStatus status;

        String expectedEmail = stringRequest.getValue();
        JwtUser existingUser = this.kairosUserService.findUserByEmail(expectedEmail);

        if (existingUser != null) {
            try {
                this.kairosEmailService.sendForgotUsernameMessage(expectedEmail, existingUser.getUsername());
                stringResponse.setValue("Username sent to " + expectedEmail + ".");
                status = HttpStatus.OK;
            } catch (Exception e) {
                stringResponse.setValue("Error sending email");
                status = HttpStatus.INTERNAL_SERVER_ERROR;
            }
        } else {
            stringResponse.setValue("No account associated with " + expectedEmail + ".");
            status = HttpStatus.NOT_FOUND;
        }
        return new ResponseEntity<>(stringResponse, status);
    }

    /**
     * Handles taking a username, finding the associated account, and emailing an
     * access code to reset the password.
     *
     * @param stringRequest The request body as json with a 'value' containing the
     *                      username.
     * @return Success or No content.
     */
    @Override
    public ResponseEntity<StringResponse> forgotPassword(
            @ApiParam("The username address of the account.") @Valid @RequestBody StringRequest stringRequest) {
        StringResponse stringResponse = new StringResponse();
        HttpStatus status;

        String expectedUsername = stringRequest.getValue();
        JwtUser existingUser = this.kairosUserService.findUserByUsername(expectedUsername);

        if (existingUser != null) {
            try {
                String accessCode = this.kairosUserService.generateAccessCodeForAccount(existingUser);
                this.kairosEmailService.sendForgotPasswordMessage(existingUser.getEmailAddress(), accessCode);
                stringResponse.setValue("Access code sent to the email associated with " + expectedUsername + ".");
                status = HttpStatus.OK;
            } catch (Exception e) {
                stringResponse.setValue("Error sending email");
                status = HttpStatus.INTERNAL_SERVER_ERROR;
            }
        } else {
            stringResponse.setValue("No account associated with " + expectedUsername + ".");
            status = HttpStatus.NOT_FOUND;
        }
        return new ResponseEntity<>(stringResponse, status);
    }

    /**
     * Handles taking an accessCode and granting a jwt to resetPassword for the
     * associated account.
     *
     * @param stringRequest The request body as json with a 'value' containing the
     *                      accessCode.
     * @return Success or Not Found.
     */
    @Override
    public ResponseEntity<StringResponse> resetPassword(
            @ApiParam("The access code to reset the password.") @Valid @RequestBody StringRequest stringRequest) {
        String accessCode = stringRequest.getValue();
        JwtUser associatedAccount = this.kairosUserService.getAccountForAccessCode(accessCode);

        if (associatedAccount != null) {    
            JwtUserDetails jwtUserDetails = new JwtUserDetails();
            jwtUserDetails.setUsername(associatedAccount.getUsername());
            jwtUserDetails.setAuthorities(new String[] { "RESET" });
            String jwt = jwtUtils.generateJwtToken(jwtUserDetails);
            return new ResponseEntity<>(new StringResponse().value(jwt), HttpStatus.OK);
        }
        return new ResponseEntity<>(new StringResponse().value("Invalid access code"), HttpStatus.NOT_FOUND);
    }

    @Override
    @PreAuthorize("hasAuthority('CREATE-SUB-ACCOUNT')")
    public ResponseEntity<StringResponse> registerUserToTeam(
            @ApiParam(value = "Registers user with password"  )  
            @Valid @RequestBody RegistrationDto registrationDto) {
        JwtUser loggedInUser = (JwtUser) this.request.getAttribute(Constants.ATTRIBUTE_JWTUSER, 0);
        loggedInUser = this.kairosUserService.findUserByUsername(loggedInUser.getUsername());
        JwtPermission subTeamPermission = this.jwtPermissionRepo.findByName(Constants.CREATE_SUB_TEAM_PERMISSION_NAME);
        List<JwtRole> roles = loggedInUser.getRoles().stream().filter(r -> !r.getPermissions().contains(subTeamPermission)).collect(Collectors.toList());
        JwtUser jwtUser = modelMapper.map(registrationDto, JwtUser.class);
        kairosUserService.assertUniqueUserName(jwtUser.getUsername());
        kairosUserService.assertUniqueEmailAddress(jwtUser.getEmailAddress());
        // Set to existing team name, no unique check
        jwtUser.roles(roles);
        jwtUser.teamName(loggedInUser.getTeamName());
        jwtUser.active(true);
        jwtUser.performerGroup(loggedInUser.getPerformerGroup());
        jwtUser.setPasswordExpiration(LocalDateTime.ofInstant(getPasswordExpiration().toInstant(), getPasswordExpiration().getTimeZone().toZoneId()).toLocalDate());
        kairosUserService.saveUserEncryptPassword(jwtUser);
        return new ResponseEntity<>(new StringResponse().value("New account " + registrationDto.getUsername() + " created."), HttpStatus.CREATED);
    }

    /**
     * Handles taking an accessCode and granting a jwt to resetPassword for the
     * associated account.
     *
     * @param stringRequest The request body as json with a 'value' containing the
     *                      new password.
     * @return Success or Unauthorized.
     */
    @Override
    @PreAuthorize("hasAuthority('RESET')")
    public ResponseEntity<StringResponse> setPassword(
            @ApiParam("The new password.") @Valid @RequestBody StringRequest stringRequest) {
        String newPassword = stringRequest.getValue();
        JwtUser jwtUser = (JwtUser) this.request.getAttribute(Constants.ATTRIBUTE_JWTUSER, 0);

        passwordValidation(newPassword);
        this.kairosUserService.updatePassword(jwtUser.getUsername(), newPassword);
        return new ResponseEntity<>(new StringResponse().value("Success."), HttpStatus.OK);
    }

    @Override
    public ResponseEntity<StringResponse> addContactRequest(@ApiParam(value = "Contact information"  )  @Valid @RequestBody ContactRequestDto contactRequestDto) {
        ContactRequestMessage contactRequestMessage = new ContactRequestMessage();
        contactRequestMessage.setSender(contactRequestDto.getRequestor());
        contactRequestMessage.setText(contactRequestDto.getMessage());

        ContactRequest contactRequest = modelMapper.map(contactRequestDto, ContactRequest.class);
        contactRequest.addMessagesItem(contactRequestMessage);

        contactRequestService.saveNewRequest(contactRequest);
        return new ResponseEntity<>(new StringResponse().value("success"), HttpStatus.OK);
    }

    @Override
    @PreAuthorize("hasAuthority('ADMIN')")
    public ResponseEntity<List<ContactRequest>> listContactRequestsByStatus(
        @ApiParam(value = "Contents to retrieve by status") @Valid @RequestParam(value = "status", required = false) String status) {
            List<ContactRequest> requestList = contactRequestService.findAllByStatus(status);
            return new ResponseEntity<>(requestList, HttpStatus.OK);
    }

    private Calendar getPasswordExpiration() {
         // update Password Expiration date
         Calendar c = Calendar.getInstance();
         c.add(Calendar.DAY_OF_MONTH, passwordExpiration);
         return c;
    }

    private Authentication getAuthentication(String username, String password) {
        try {
            return authenticationManager.authenticate(
                    new UsernamePasswordAuthenticationToken(username, password));
        } catch (BadCredentialsException e) {
            e.printStackTrace();
            throw new ResponseStatusException(HttpStatus.UNAUTHORIZED, "Error: Invalid username or password");
        }
    }
}
