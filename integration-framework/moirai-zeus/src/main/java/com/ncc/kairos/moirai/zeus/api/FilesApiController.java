package com.ncc.kairos.moirai.zeus.api;

import com.google.gson.Gson;
import com.ncc.kairos.moirai.zeus.exceptions.UnaccessibleEndpointException;
import com.ncc.kairos.moirai.zeus.model.*;
import com.ncc.kairos.moirai.zeus.resources.Constants;
import com.ncc.kairos.moirai.zeus.services.FilesService;
import com.ncc.kairos.moirai.zeus.services.KairosUserService;
import com.ncc.kairos.moirai.zeus.services.PropertiesService;
import com.ncc.kairos.moirai.zeus.services.ValidationService;
import com.ncc.kairos.moirai.zeus.utililty.TimeUtil;

import io.swagger.annotations.ApiParam;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.io.ByteArrayResource;
import org.springframework.core.io.Resource;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.context.request.NativeWebRequest;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.server.ResponseStatusException;
import org.apache.commons.lang3.StringUtils;

import javax.validation.Valid;
import javax.validation.constraints.NotNull;
import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.*;
/**
 * Controller Implementation of the Files Api that is autogenerated by
 * swagger-codegen.
 *
 * @author Ryan Scott
 */
@Controller
@RequestMapping("${openapi.moiraiZeus.base-path:}")
public class FilesApiController implements FilesApi {

    private final NativeWebRequest request;

    @Autowired
    public FilesApiController(NativeWebRequest request) {
        this.request = request;
    }

    public Optional<NativeWebRequest> getRequest() {
        return Optional.ofNullable(this.request);
    }

    @Autowired
    private KairosUserService kairosUserService;

    @Autowired
    private ValidationService validationService;

    @Autowired
    private PropertiesService propertiesService;

    @Autowired
    private FilesService filesService;

    @Override
//    @PreAuthorize("hasAuthority('FILE-DELETE')")
    public ResponseEntity<StringResponse> deleteFile(@ApiParam(value = "file id", required = true) @PathVariable("id") String id) {
        JwtUser jwtUser = (JwtUser) this.request.getAttribute(Constants.ATTRIBUTE_JWTUSER, 0);
        jwtUser = kairosUserService.findUserByUsername(jwtUser.getUsername());
        kairosUserService.assertUserExists(jwtUser.getUsername());

        filesService.deleteFileByOwnerAndId(jwtUser.getTeamName(), id);
        return new ResponseEntity<>(HttpStatus.OK);
    }

    @Override
//    @PreAuthorize("hasAuthority('FILE-READ')")
    public ResponseEntity<List<StoredFile>> getFiles(@NotNull @ApiParam(value = "which experiment to get files for.", required = true) @Valid @RequestParam(value = "experiment", required = true) String experiment) {
        JwtUser jwtUser = (JwtUser) this.request.getAttribute(Constants.ATTRIBUTE_JWTUSER, 0);
        jwtUser = kairosUserService.findUserByUsername(jwtUser.getUsername());
        kairosUserService.assertUserExists(jwtUser.getUsername());

        List<StoredFile> files = filesService.getBaseFilesByOwnerAndExperiment(jwtUser.getTeamName(), experiment);
        return new ResponseEntity<List<StoredFile>>(files, HttpStatus.OK);
    }

    @Override
//    @PreAuthorize("hasAuthority('FILE-READ')")
    public ResponseEntity<List<StoredFile>> getFilesByExperiment(@NotNull @ApiParam(value = "which experiment to get files for.", required = true) @Valid @RequestParam(value = "experiment", required = true) String experiment) {
        JwtUser jwtUser = (JwtUser) this.request.getAttribute(Constants.ATTRIBUTE_JWTUSER, 0);
        jwtUser = kairosUserService.findUserByUsername(jwtUser.getUsername());
        kairosUserService.assertUserExists(jwtUser.getUsername());

        List<StoredFile> files = filesService.getBaseFilesWithPublicAccess(experiment);
        return new ResponseEntity<List<StoredFile>>(files, HttpStatus.OK);
    }

    @Override
//    @PreAuthorize("hasAuthority('FILE-READ')")
    public ResponseEntity<List<StoredFile>> getFilesByEvaluation(@NotNull @ApiParam(value = "which evaluation to get files for.", required = true) @Valid @RequestParam(value = "evaluation", required = true) String evaluation) {
        JwtUser jwtUser = (JwtUser) this.request.getAttribute(Constants.ATTRIBUTE_JWTUSER, 0);
        jwtUser = kairosUserService.findUserByUsername(jwtUser.getUsername());
        kairosUserService.assertUserExists(jwtUser.getUsername());

        List<StoredFile> files = filesService.getBaseFilesByExperiment(evaluation);
        return new ResponseEntity<List<StoredFile>>(files, HttpStatus.OK);
    }

    @Override
//    @PreAuthorize("hasAuthority('FILE-WRITE')")
    public ResponseEntity<StringResponse> handleUpload(@ApiParam(value = "file detail") @Valid @RequestPart("file") MultipartFile file,
                                                       @ApiParam(value = "", required = true) @RequestParam(value = "filename", required = true) String filename,
                                                       @ApiParam(value = "", required = true) @RequestParam(value = "experiment", required = true) String experiment,
                                                       @ApiParam(value = "", required = true) @RequestParam(value = "category", required = true) String category,
                                                       @ApiParam(value = "") @RequestParam(value = "extraData", required = false) String extraData,
                                                       @ApiParam(value = "", required = false, defaultValue="false") @RequestParam(value="createHistory", required=true)  Boolean createHistory) {
        JwtUser jwtUser = (JwtUser) this.request.getAttribute(Constants.ATTRIBUTE_JWTUSER, 0);
        jwtUser = kairosUserService.findUserByUsername(jwtUser.getUsername());
        kairosUserService.assertUserExists(jwtUser.getUsername());

        File inputFile = null;
        try {
            inputFile = FilesService.convertMultiPartFile(file);
        } catch (IOException e) {
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Unable to process multipart file");
        }

        if (file != null) {
            StoredFile newFile = filesService.saveNewFile(inputFile, filename, jwtUser.getTeamName(), experiment, category, extraData, true); // display flag
            //Temporarily disable validation of uploaded files
            if (validationService.shouldValidate() && filename.toLowerCase().endsWith("json") || filename.toLowerCase().endsWith("jsonld") || filename.toLowerCase().endsWith("json-ld")) {
                // We just automatically attempt to validate and convert every json file, if the job fails we note it.
                filesService.createValidationJob(newFile);
                filesService.createHumanReadableJob(newFile);

            } else {
                newFile.setCanSubmit(true);
                filesService.save(newFile);
                // Create file history record
                if (propertiesService.getCreateHistory() && createHistory) {
                    String historyFileName = StringUtils.substringBeforeLast(filename, ".");
                    String extension = StringUtils.substringAfterLast(filename, ".");
                    historyFileName += "-T-" + TimeUtil.getTimeInSeconds() + (extension.equals("") ? "" : "." + extension);
                    StoredFile historyFile = filesService.saveNewFile(inputFile, historyFileName, jwtUser.getTeamName(), experiment, category, extraData, false);
                    historyFile.display(false);
                    filesService.save(historyFile);
                }
            }
        }
        return new ResponseEntity<>(HttpStatus.OK);
    }

    @Override
//    @PreAuthorize("hasAuthority('FILE-WRITE')")
    public ResponseEntity<StringResponse> updateFile(@ApiParam(value = "file id", required = true) @PathVariable("id") String id, @ApiParam(value = "Update the file given the id") @Valid @RequestBody StoredFile storedFile) {
        JwtUser jwtUser = (JwtUser) this.request.getAttribute(Constants.ATTRIBUTE_JWTUSER, 0);
        jwtUser = kairosUserService.findUserByUsername(jwtUser.getUsername());
        kairosUserService.assertUserExists(jwtUser.getUsername());
        
        if (!id.equals(storedFile.getId())) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Invalid: id in object does not match id in path");
        }
        
        filesService.save(storedFile);
        return new ResponseEntity<>(HttpStatus.OK);

    }

    @Override
//    @PreAuthorize("hasAuthority('FILE-DOWNLOAD')")
    public ResponseEntity<Resource> downloadFile(@ApiParam(value = "file id", required = true) @PathVariable("id") String id) {
        JwtUser jwtUser = (JwtUser) this.request.getAttribute(Constants.ATTRIBUTE_JWTUSER, 0);
        jwtUser = kairosUserService.findUserByUsername(jwtUser.getUsername());
        kairosUserService.assertUserExists(jwtUser.getUsername());

        StoredFile file = filesService.getStoredFile(id);
        try {
            final byte[] data = filesService.downloadFile(file);
            final ByteArrayResource resource = new ByteArrayResource(data);
            return ResponseEntity
                    .ok()
                    .contentLength(data.length)
                    .header("Content-type", "application/octet-stream")
                    .header("Content-Disposition", "attachment; filename=\"" + file.getFilename() + "\"")
                    .body(resource);
        } catch (Exception e) {
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Unable to get multipart file");
        }
    }

    @Override
    public ResponseEntity<StringResponse> validateFile(@ApiParam(value = "file id", required = true) @PathVariable("id") String id) {
        StoredFile storedFile = filesService.getStoredFile(id);
        filesService.createValidationJob(storedFile);
        return new ResponseEntity<>(HttpStatus.OK);
    }

    @Override
//    @PreAuthorize("hasAuthority('FILE-READ')")
    public ResponseEntity<FileDisplayInfo> displayFiles(@ApiParam(value = "file id", required = true) @PathVariable("id") String id) {
        StoredFile storedFile = filesService.getStoredFile(id);

        FileDisplayInfo fileDisplayInfo = new FileDisplayInfo();
        fileDisplayInfo.setFileId(id);
        fileDisplayInfo.setFilename(storedFile.getFilename());
        try {
            String base = new String(filesService.downloadFile(storedFile), StandardCharsets.UTF_8);
            fileDisplayInfo.setBase(base);
        } catch (Exception e) {
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Error: Unable to read " + storedFile.getFilename() + ".");
        }

        if (storedFile.getValidationDone()) {
            try {
                String validation = new String(filesService.downloadFileValidation(storedFile), StandardCharsets.UTF_8);
                fileDisplayInfo.setValidation(validation);
            } catch (Exception e) {
                fileDisplayInfo.setValidation("Unable to validate " + storedFile.getFilename() + ".");
            }
        }

        if (storedFile.getHumanReadableDone()) {
            try {
                String humanreadable = new String(filesService.downloadFileHumanReadable(storedFile), StandardCharsets.UTF_8);
                fileDisplayInfo.setHumanReadable(humanreadable);
            } catch (Exception e) {
                fileDisplayInfo.setValidation("Unable to convert " + storedFile.getFilename() + " to human readable form.");
            }
        }
        return new ResponseEntity<>(fileDisplayInfo, HttpStatus.OK);
    }

    @Override
    @PreAuthorize("hasAuthority('ADMIN')")
    public ResponseEntity<StringResponse> experimentSnapshot(@NotNull @ApiParam(value = "which experiment to take snapshot of.", required = true) @Valid @RequestParam(value = "experiment", required = true) String experiment) {
        List<StoredFile> files = filesService.getBaseFilesWithPublicAccess(experiment);
        List<StoredFile> notCopied = new ArrayList<>();
        Date now = new Date();
        String snapName = experiment + "_snap_" + now.getTime();

        for (StoredFile file : files) {
            StoredFile copy = new Gson().fromJson(new Gson().toJson(file), StoredFile.class);
            copy.setId(null);
            copy.setExperiment(snapName);
            copy.setUri(filesService.generateUriForFile(copy));

            try {
                filesService.copyFile(file, copy);
                filesService.save(copy);
            } catch (Exception e) {
                notCopied.add(file);
            }
        }

        if (notCopied.size() > 0) {
            return new ResponseEntity<>(new StringResponse().value(notCopied.toString()), HttpStatus.EXPECTATION_FAILED);
        } else {
            return new ResponseEntity<>(HttpStatus.OK);
        }
    }

    @Override
    @PreAuthorize("hasAuthority('ADMIN')")
    public ResponseEntity<StringResponse> copyExperimentFiles(@NotNull @ApiParam(value = "which snapshot to copy.", required = true) @Valid @RequestParam(value = "snapshot", required = true) String snapshot, @NotNull @ApiParam(value = "which experiment to put files under.", required = true) @Valid @RequestParam(value = "experiment", required = true) String experiment) {
        try {
            filesService.copySnapshotToExperiment(snapshot, experiment);
        } catch (Exception e) {
            return new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR);
        }
        return new ResponseEntity<>(HttpStatus.OK);
    }

    @Override
    public ResponseEntity<StringResponse> syncFiles() {
        List<StoredFile> storedFiles = filesService.getAll();
        for (StoredFile file : storedFiles) {
            if (!file.getUri().startsWith("s3://")) {
                file.setUri(filesService.uriFromKey(file.getUri()));
                filesService.save(file);
            }
        }
        filesService.findOrDelete(storedFiles);
        filesService.findOrAdd();
        filesService.correctPaths();

        return new ResponseEntity<>(HttpStatus.OK);
    }

    @Override
    public ResponseEntity<ValidationResponse> validateInput(@ApiParam(value = "Input to validate"  )  @Valid @RequestBody ValidationRequest validationRequest) {
        try {
            ValidationResponse vr = validationService.runValidation(validationRequest.getInput());
            return new ResponseEntity<>(vr, HttpStatus.OK);
        } catch (UnaccessibleEndpointException e) {
            ValidationResponse validationResponse = new ValidationResponse()
                    .warningsList(new ArrayList<>())
                    .errorsList(Collections.singletonList("Error: "+e.getLocalizedMessage()));
            return new ResponseEntity<>(validationResponse, HttpStatus.OK);
        }
    }
}